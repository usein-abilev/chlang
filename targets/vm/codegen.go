package vm

import (
	"fmt"
	"strconv"

	"github.com/usein-abilev/chlang/frontend/ast"
	"github.com/usein-abilev/chlang/frontend/token"
)

// The codegen package generates the assembly code for the RVM (register based VM).
// It takes the AST generated by the frontend package for input and process compiling stage.
// But 200 AST representation should replaced with the intermediate representation (IR) of the program in the future.
type RVMGenerator struct {
	program *ast.Program

	// current allocator context
	allocator *RegisterAllocator
	function  *FunctionObject
	builder   *ASMBuilder
}

func NewRVMGenerator(program *ast.Program) *RVMGenerator {
	moduleFunction := &FunctionObject{
		name:         "<module>",
		instructions: make([]VMInstruction, 0),
		contextType:  ModuleContext,
		registers:    make([]LocalRegister, 0),
		constants:    make(map[string]OperandValue),
	}

	// add build-in functions
	for name, function := range BuildInFunctions {
		moduleFunction.addConstant(name, OperandValue{
			Kind:  OperandTypeBuildInFunction,
			Value: function,
		})
	}

	return &RVMGenerator{
		program:   program,
		function:  moduleFunction,
		builder:   NewASMBuilder(moduleFunction),
		allocator: NewRegisterAllocator(&moduleFunction.registers),
	}
}

func (g *RVMGenerator) Generate() *FunctionObject {
	for _, statement := range g.program.Statements {
		g.emitStatement(statement)
	}
	g.builder.Print()
	return g.function
}

func (g *RVMGenerator) emitStatement(statement ast.Statement) {
	switch statement := statement.(type) {
	case *ast.ConstDeclarationStatement:
		value := getOperandValueFromConstant(statement.Value)
		g.function.addConstant(statement.Name.Value, value)
	case *ast.VarDeclarationStatement:
		g.visitVarDeclaration(statement)
	case *ast.FuncDeclarationStatement:
		g.visitFuncDeclaration(statement)
	case *ast.ReturnStatement:
		returnRegister := g.emitExpressionToRegister(statement.Expression)
		g.builder.Emit(OpcodeReturn, returnRegister, 1)
	case *ast.ExpressionStatement:
		g.emitExpressionToRegister(statement.Expression)
	case *ast.BlockStatement:
		g.allocator.EnterScope()
		for _, statement := range statement.Statements {
			g.emitStatement(statement)
		}
		g.allocator.LeaveScope()
	default:
		panic(fmt.Sprintf("unknown statement type '%T'", statement))
	}
}

func (g *RVMGenerator) visitVarDeclaration(decl *ast.VarDeclarationStatement) {
	if decl.Value == nil {
		g.allocator.AllocateRegister(decl.Name.Value)
		return
	}
	leftRegister := g.emitExpressionToRegister(decl.Value)
	bound := g.allocator.BindRegister(decl.Name.Value, leftRegister)
	registerId := leftRegister
	if !bound {
		// if the result of the expression is variable's register, then it should be moved to another register
		// for example, the expression 'x = y' produces two variable registers r(x) and r(y),
		// so binding register r(x) = r(y) will override each other and we lose access to variable 'y'
		registerId = g.allocator.AllocateRegister(decl.Name.Value)
		g.builder.Emit(OpcodeMove, registerId, leftRegister)
	}
}

func (g *RVMGenerator) visitFuncDeclaration(decl *ast.FuncDeclarationStatement) {
	parentFunction := g.function
	g.function = &FunctionObject{
		name:         decl.Name.Value,
		parent:       parentFunction,
		contextType:  FunctionContext,
		instructions: make([]VMInstruction, 0),
		registers:    make(RegisterTable, 0),
		constants:    make(map[string]OperandValue),
	}
	parentBuilder := g.builder
	g.builder = NewASMBuilder(g.function)
	parentFunction.addConstant(decl.Name.Value, OperandValue{
		Kind:  OperandTypeFunctionObject,
		Value: g.function,
	})
	parentAllocator := g.allocator
	g.allocator = NewRegisterAllocator(&g.function.registers)

	// Rollback changes and go back to the parent context, function and allocator
	defer (func() {
		g.function = parentFunction
		g.builder = parentBuilder
		g.allocator = parentAllocator
	})()

	for _, argument := range decl.Params {
		g.allocator.AllocateRegister(argument.Name.Value)
	}

	for _, bodyStatement := range decl.Body.Statements {
		g.emitStatement(bodyStatement)
	}
}

func (g *RVMGenerator) emitExpressionToRegister(expression ast.Expression) RegisterAddress {
	switch expr := expression.(type) {
	case *ast.IfExpression:
		condRegister := g.emitExpressionToRegister(expr.Condition)
		falseBranch := g.builder.Emit(OpcodeJumpIf)
		g.emitStatement(expr.ThenBlock)
		thenBranch := g.builder.Emit(OpcodeJump)
		g.builder.PatchInstruction(falseBranch, condRegister, false, RegisterAddress(len(g.function.instructions)))
		if expr.ElseBlock != nil {
			switch expr.ElseBlock.(type) {
			case *ast.BlockStatement:
				g.emitStatement(expr.ElseBlock)
			case *ast.IfExpression:
				g.emitExpressionToRegister(expr.ElseBlock)
			}
		}
		g.builder.PatchInstruction(thenBranch, RegisterAddress(len(g.function.instructions)))
		return condRegister
	case *ast.UnaryExpression:
		targetReg := g.allocator.AllocateTempRegister()
		operandReg := g.emitExpressionToRegister(expr.Right)
		switch expr.Operator.Type {
		case token.BANG:
			g.builder.Emit(OpcodeNot, targetReg, operandReg)
		default:
			panic(fmt.Sprintf("error: unknown unary operator '%s'", expr.Operator.Literal))
		}
		return targetReg
	case *ast.CallExpression:
		calleeReg := g.allocator.AllocateTempRegister()
		g.builder.Emit(OpcodeLoadConst, calleeReg, expr.Function.Value)
		for _, argumentExpr := range expr.Args {
			register := g.emitExpressionToRegister(argumentExpr)
			if !g.allocator.IsTempRegister(register) {
				tempRegister := g.allocator.AllocateTempRegister()
				g.builder.Emit(OpcodeMove, tempRegister, register)
			}
		}
		g.builder.Emit(OpcodeCall, calleeReg, len(expr.Args), 1)
		returnAddress := g.allocator.AllocateTempRegister()
		return RegisterAddress(returnAddress)
	case *ast.AssignExpression:
		targetReg := g.emitExpressionToRegister(expr.Left)
		switch expr.Operator.Type {
		case token.ASSIGN:
			leftReg := g.emitExpressionToRegister(expr.Right)
			g.builder.Emit(OpcodeMove, targetReg, leftReg)
			return leftReg
		}
		panic(fmt.Sprintf("unknown assign expression operator '%s'", expr.Operator.Literal))
	case *ast.BinaryExpression:
		targetReg := g.allocator.AllocateTempRegister()

		if token.IsLogicalOperator(expr.Operator.Type) {
			// logical operators are not implemented yet
			switch expr.Operator.Type {
			case token.AND:
				leftReg := g.emitExpressionToRegister(expr.Left)
				falseBranch := g.builder.Emit(OpcodeJumpIf)
				rightReg := g.emitExpressionToRegister(expr.Right)
				g.builder.PatchInstruction(falseBranch, leftReg, false, RegisterAddress(len(g.function.instructions)))
				g.builder.Emit(OpcodeMove, targetReg, rightReg)
			case token.OR:
				// g.builder.Emit(OpcodeBitwiseOr, targetReg, leftReg, rightReg)
			default:
				panic(fmt.Sprintf("error: unknown logical operator '%s'", expr.Operator.Literal))
			}
			return targetReg
		}

		leftReg := g.emitExpressionToRegister(expr.Left)
		rightReg := g.emitExpressionToRegister(expr.Right)

		switch expr.Operator.Type {
		case token.PLUS:
			g.builder.Emit(OpcodeAdd, targetReg, leftReg, rightReg)
		case token.MINUS:
			g.builder.Emit(OpcodeSub, targetReg, leftReg, rightReg)
		case token.ASTERISK:
			g.builder.Emit(OpcodeMul, targetReg, leftReg, rightReg)
		case token.SLASH:
			g.builder.Emit(OpcodeDiv, targetReg, leftReg, rightReg)
		case token.EQUALS:
			g.builder.Emit(OpcodeEq, targetReg, leftReg, rightReg)
		case token.GREATER:
			g.builder.Emit(OpcodeGt, targetReg, leftReg, rightReg)
		case token.LESS:
			g.builder.Emit(OpcodeLt, targetReg, leftReg, rightReg)
		default:
			panic(fmt.Sprintf("error: unknown operator '%s'", expr.Operator.Literal))
		}

		return targetReg
	case *ast.IntLiteral:
		integer, _ := strconv.ParseInt(expr.Value, 0, 64)
		reg := g.allocator.AllocateTempRegister()
		g.builder.Emit(OpcodeLoadImm32, reg, integer)
		return reg
	case *ast.BoolLiteral:
		var value bool
		switch expr.Value {
		case "true":
			value = true
		case "false":
			value = false
		default:
			panic(fmt.Sprintf("error: invalid boolean value: %s", expr.Value))
		}
		reg := g.allocator.AllocateTempRegister()
		g.builder.Emit(OpcodeLoadBool, reg, value)
		return reg
	case *ast.StringLiteral:
		reg := g.allocator.AllocateTempRegister()
		g.builder.Emit(OpcodeLoadString, reg, expr.Value)
		return reg
	case *ast.Identifier:
		local, ok := g.allocator.LookupVariable(expr.Value)
		if !ok {
			if constant := g.function.lookupConstant(expr.Value); constant == nil {
				panic(fmt.Sprintf("error: unresolved symbol '%s' at %s\n", expr.Value, expr.Token.Position))
			}
			registerId := g.allocator.AllocateTempRegister()
			g.builder.Emit(OpcodeLoadConst, registerId, expr.Value)
			return registerId
		} else {
			return local.register
		}
	}

	panic(fmt.Sprintf("error: unknown expression type: %T", expression))
}

func (f *FunctionObject) addConstant(name string, value OperandValue) {
	f.constants[name] = value
}

func (ctx *FunctionObject) lookupConstant(name string) *OperandValue {
	for {
		if value, ok := ctx.constants[name]; ok {
			return &value
		}
		ctx = ctx.parent
		if ctx == nil {
			return nil
		}
	}
}

func getOperandValueFromConstant(expr ast.Expression) OperandValue {
	switch expr := expr.(type) {
	case *ast.IntLiteral:
		value, err := strconv.ParseInt(expr.Value, expr.Base, 64)
		if err != nil {
			panic("getOperandValueFromConstant: invalid int literal")
		}
		return OperandValue{
			Kind:  OperandTypeInt64,
			Value: value,
		}
	case *ast.StringLiteral:
		return OperandValue{
			Kind:  OperandTypeString,
			Value: expr.Value,
		}
	}
	return OperandValue{Kind: OperandTypeUndefined, Value: nil}
}
